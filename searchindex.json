{"categories":[{"title":"学习篇","uri":"https://sleepshow.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"posts":[{"content":"基础知识 1. 操作：   蓝图连线颜色：相同颜色表示蓝图之间可以连接，相似颜色表示需要通过专用节点进行连接，不同颜色不能连接；\n  要经常进行保存；\n  2. 节点   组成部分：标题（不同的节点不同的颜色）、输入部分（从其他节点接收数据）、输出部分（传递数值到其他节点），位于输入输出部分的项目，称为“引脚”；\n  处理顺序：从左至右；\n  1️⃣ 事件节点：\n 当用户操作或者在游戏场景中发生了某件事时，就会触发事件，从而呼出该事件的节点； 标题颜色：红色； 右侧带有白色的五角形标志，表示执行处理的流程； 事件BeginPlay 节点：打开关卡，即在开始玩游戏时，最先发生的事件； EndPlay  节点：结束关卡，最后发生的事件；    命令节点：\n  执行各种处理的节点；\n  2️⃣ 执行节点：\n 标题颜色：蓝色； 左右两侧都有白色五角形标志； 通过其他事件的五角形标志连接，而呼出节点； Print String 节点：将文本输出到画面或者日志内，下拉列表可以选择打印到屏幕/日志，以及更改文本颜色；    3️⃣ 读取节点：\n  向其他节点传递必要信息；\n  标题颜色：绿色；\n  不能从事件连接到该节点；\n  节点右侧通常显示为“Return Value”，用于将信息传递给接受读取出值的项目；\n  Make Literal String 节点：\n​\t- Value —— 创建文本（可直接输入，可从其他节点接收）；\n​\t- Reutrn Value —— 读取该文本的值；\n  Mark Literal Int 节点：操作类似 string 节点，将数字返回到字符串系统会自动添加类型转换节点；\n      注意右上角的“情景关联”；\n  3. 值的类型  文本、字符串：Text、String； 整型、浮点型：Int、Float； 布尔型：Bool； + / - / x / ÷ 节点：四则运算，“添加引脚”表示在输入侧添加项目，减法和除法不能添加引脚； 添加数学表达式 节点：在命令菜单最下方，新建用于复杂计算的数学表达式节点，在输入框输入表达式会自动生成输入输出项目； 变量：在蓝图编辑器左侧，需要手动添加设置；  4. 数组  先将变量类型设置成整型，点击整型右侧的绿色方格图标，可以进行数组和变量切换； Set Array Elem 节点：用于修改数组中保管的数值；\n- Target Array —— 连接设置数值的数组；\n- Index —— 规定设置项目的编号，可以修改指定编号的值；\n- Item —— 用于连接设置值，将与Item连接的值保存在Index指定的编号中； - Size to Fit —— 如果有项目未使用，就删除掉，负责整理保留使用的项目； Get 节点：获取数组中保管的数值，需要与数组连接，输入取值的编号； Remove Index 节点：删除指定编号的数值；  ","id":0,"section":"blog","summary":"基础知识 1. 操作： 蓝图连线颜色：相同颜色表示蓝图之间可以连接，相似颜色表示需要通过专用节点进行连接，不同颜色不能连接； 要经常进行保存； 2. 节点 组","tags":["蓝图"],"title":"《UNREAL ENGINE4 蓝图完全学习教程》笔记","uri":"https://sleepshow.github.io/2022/05/blueprint/","year":"2022"},{"content":"向量 1. 概念  图形学默认向量是一个列向量；  2. 向量点乘 （·）   点乘的结果是一个值；\n    满足交换律、结合律、分配律；\n  在图形学中的作用是找到两个向量/方向的夹角，比如：光线夹角，物体表面法线等等\n  可以将一个向量在另外一个向量上的投影计算出来；\n  可以看出物体前后位置的信息；\n    当两向量的夹角 \u0026gt; 0 ，表示方向相反；\n  当两向量的夹角 \u0026lt; 0，表示方向相同\n    3. 向量叉乘（x）     叉乘的结果是一个向量；\n  右手螺旋定则：除大拇指外的四个手指表示旋转方向，大拇指表示叉乘结果后的方向，如：\n 求 a x b，就是从 a 旋转到 b 后大拇指的方向朝上； 求 b x a，则大拇指方向朝下；    用于建立三维空间的直角坐标系，比如：\n  在三维空间中，给定一个 x，y 轴，可以算出 z 轴；\n  在三维空间中，给定一个 y，z 轴，可以算出 x 轴；\n  在三维空间中，给定一个 x，z 轴，可以算出 y 轴；\n    没有交换律，满足结合律、分配律；\n  判断两向量的左/右：\n a x b 得出的结果 z 是一个正数，表示 b 在 a 的左侧； b x a 得出的结果 z 是一个负数，表示 a 在 b 的右侧；    判断点 P 在三角形内/外部：\n 在内部：P 点一定在都三条边的左边/右边；    矩阵 1. 概念  由行，列组成； 矩阵点乘：   没有交换律（即不可以位置对调），满足结合律、分配律；   让 x / y 变成负的：     矩阵的转置：      变换 1. 二维变换 （1）缩放变换：    （2）反转变换：    （3）切变换：    （4）旋转：    总结：  上面四种变换均是线性变换：   2. 齐次坐标 （1）向量具有不变性，即无论怎么平移，向量都不会发生改变； （2）一个点减去另外一个点，等于一个向量； （3）对于一个 2D 的点：     （4）对于一个 2D 的向量：    （5）逆变换：一个矩阵乘以它的逆矩阵，结果为一个单位矩阵； 3. 三维变化   在描述三维空间中，仿射变换的情况下对应矩阵的最后一行永远都是0,0,0\u0026hellip;,1；   （1）缩放、平移和二维类似； （2）旋转（绕着某一固定轴旋转）：    变换组合 （1）旋转默认以原点为中心，方向为逆时针； （2）变换的顺序很重要；  先平移，后旋转 与 先旋转，后平移的区别：      （3）旋转的逆（往相反的方向旋转相同的角度）：  先正向旋转，再进行转置； 正交矩阵：一个矩阵的逆等于它的转置  ","id":1,"section":"blog","summary":"向量 1. 概念 图形学默认向量是一个列向量； 2. 向量点乘 （·） 点乘的结果是一个值； 满足交换律、结合律、分配律； 在图形学中的作用是找到两个向量/方向的","tags":["图形学"],"title":"Games101 现代图形学笔记","uri":"https://sleepshow.github.io/2022/05/games101/","year":"2022"},{"content":"例题 来自刷题网站LeetCode \u0026ldquo;464.我能赢吗\u0026rdquo;\n 题目描述：\n（1）在 \u0026ldquo;100 game\u0026rdquo; 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和达到或超过100 的玩家，即为胜者。\n（2）如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？\n（3）例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 \u0026gt;= 100。\n（4）给定两个整数 maxChoosableInteger （整数池中可选择的最大数）和 desiredTotal（累计和），若先出手的玩家是否能稳赢则返回 true ，否则返回 false 。假设两位玩家游戏时都表现最佳。\n 定理内容均来自 知乎\nSprague-Grundy定理（简称SG） 1. 满足下列条件：  双人、回合制； 信息完全公开； 无随机因素； 必然在有限步数内结束； 没有平局； 双方可采取的行动及胜利目标都相同； 这个胜利目标是自己亲手达成终局状态，或者说走最后一步者为胜；  则游戏中的任何一个状态，要么先手有必胜策略（胜态），要么后手有必胜策略（败态）。\n2. 必胜策略的构造过程  对于终局状态，根据游戏规则可以判定“先手者”（即面对此状态的玩家）的胜负； 对于非终局状态A，可以考虑先手玩家走一步之后的所有可能状态（称为A的“次态”）：若A的次态全都是胜态，则A本身就是败态；否则，A为胜态，且必胜策略就是在次态中选择一个败态留给对方。由于游戏会在有限步内结束，这个递归过程必然能够终止。  根据策海格 定理，使用记忆化搜索算法判断一个状态是胜态还是败态：\n// 使用哈希表存放状态 unordered_map\u0026lt;int,bool\u0026gt; men; // 判断状态A是否为胜态 bool win(A){ if(!men.count(A)){ if(isFinal(A)){ // 若A为终局 men[A] = rule(A); // 根据题目规则判断A的胜负 } else { // 并非正确语句，只是为了方便理解 // 判断A的所有次态是否是败态 men[A] = (!win(for(auto B : nextStates(A)))); } } }  根据 Sprague-Grundy 定理满足条件，题目中的每个状态都可以按照下面规则赋予一个非负整数，称为 Sprague-Grundy 数：\n SG（A） = mex {SG（B） | A -\u0026gt; B} 式中：A,B表示状态，A-\u0026gt;B代表A状态经一步行动可以到达B状态，mex表示一个集合所不包含的最小非负整数；  SG数的性质：\n SG数为0的状态，后手必胜；SG数为正的状态，先手必胜； 若一个母状态可以拆分成多个相互独立的子状态，则母状态的SG数等于各个子状态的SG数的异或。  将记忆化搜索程序进行优化：\n// 编写语言 python mem = {} def SG(A): // 定义一个函数，求状态A的SG数 if A not in mem: S = sub_states(A) // sub_states(A)将A尽可能细致地拆分成子状态 if len(S) \u0026gt; 1: // A可以拆分，用子状态的异或求其SG数 mem[A] = reduce(operator.xor, [SG(B) for B in S]) else: // A不可拆分，根据定义求其SG数 // next_states(A)返回A的所有次态\u0026lt;注意这条语句蕴含了“终局态的SG数为0” mem[A] = mex(set(SG(B) for B in next_states(A))) return mem[A]  ","id":2,"section":"blog","summary":"例题 来自刷题网站LeetCode \u0026ldquo;464.我能赢吗\u0026rdquo; 题目描述： （1）在 \u0026ldquo;100 game\u0026rdquo; 这个游戏中，两名玩家轮流选择从 1 到 10 的任意","tags":["Sprague-Grundy"],"title":"Sprague-Grundy定理理解","uri":"https://sleepshow.github.io/2022/05/sprague_grundy/","year":"2022"},{"content":"纯虚函数与抽象类 1. 纯虚函数  没有函数体的虚函数； C++中的纯虚函数/抽象函数是没有实现的虚函数，只需要通过在声明中赋值0来实现纯虚函数。  // 抽象类 class Test{ public: // 声明虚函数,只需要赋值0即为纯虚函数 virtual void show() = 0; };  2. 抽象类  至少包含一个纯虚函数的类； 只能作为基类来派生新类使用，不能创建对象； 可以创建指针和引用，指向由抽象类派生出来的类的对象；  // 利用上面代码的Test抽象类 int main(){ Test test; // 错误，不能创建对象 Test *test1; // 正确，可以创建抽象类的指针 Test *test2 = new Test(); // 错误，Test是抽象类，不能创建对象 }   抽象类中，成员函数内可以调用纯虚函数，构造函数/析构函数不能使用纯虚函数； 一个从抽象类派生而来的，必须实现基类中所有的纯虚函数，才是非抽象类；  // 利用上面代码的Test抽象类 class TestA : public Test{ void show(){ cout \u0026lt;\u0026lt; \u0026quot;Test的派生类：TestA\u0026quot; \u0026lt;\u0026lt; endl; } }; int main(){ TestA a; a.show(); return 0; }   构造函数不能是虚函数，但是析构函数可以是虚析构函数，当基类指针指向派生类对象并删除它时，会希望调用合适的析构函数，如果析构函数不是虚函数，则只能调用基类析构函数。  assert 断言  是宏，而非函数，原型定义在\u0026lt;assert.h\u0026gt;(C，C++)中； 作用：如果其条件返回错误，终止程序执行； 需要在源代码开头，即include\u0026lt;assert.h\u0026gt;之前定义 NDEBUG 来关闭assert；  #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main(){ int x = 7; // 程序中间有些大的代码使得x的值意外发生了改变 x = 9; // 程序员判断x的值是否改变，若改变则终止程序 assert(x == 7); return 0; }   断言主要用于检查逻辑上不可能的情况，可用在代码运行之前或者之后； 断言通常在运行时被禁用。  位域（Bit Field） 1. 位域的性质  定义：一种数据结构，可以把数据以位的形式紧凑的储存，并允许程序员对此结构的位进行操作； 优点：节省空间，对于程序需要成千上万个数据单元时，位域极其适用； 缺点：是不可移植的，实现依赖于机器和系统，不同的平台可能有不同的结果； 位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定； 取地址运算符（\u0026amp;）不能作用于位域，任何指针都无法指向类的位域。  2. 位域的使用  使用结构体声明，为每个位域成员设置名称和宽度；  // bitFieldName 位域结构名 // type 位域成员的类型，必须为int/signed int/unsigned int类型 // memberName 位域成员名字 // width 成员所占的位数(bits) struct bitFieldName{ type memberName : width; };   声明后可以对位域成员进行赋值，注意值的大小不能超过位与成员的容量,即位数。  3. 位域的大小  例如下面的代码：　  struct box{ unsigned int a : 1; unsigned int : 3; unsigned int b : 4; }   该结构体中有一个未命名的位域，仅起填充作用，并没有实际意义； 在C语言中使用 unsigned int 作为位域的基本单位，即使一个结构的唯一成员为 1 Bit 的位域，该结构大小也和一个 unsigned int 大小相同； 某些系统中，unsigned int 为 16 Bits，在 x86 系统中为 32 Bits。本文中均默认 unsigned int 为 32 Bits。  4. 位域的对齐  一个位域成员不能跨越两个unsigned int的边界，若成员的总位数超过了一个unsigned int的大小，则编译器就会自动将位域成员移位，使其按照unsigned int的边界对其； 例如下面的代码：  struct stuff { unsigned int field1 : 30; unsigned int field2 : 4; unsigned int field3 : 3; };   结构中前两个成员的总位数为34bits，超过了32bits，则编译器会将field2移位至下一个unsigned int单元中； field1和field2中有一个2bits的空隙，可以用前面提到过的未命名的位域成员填充，也可以使用一个位数为0的位域成员将下一个位域成员与下一个整数单元对齐。  #include \u0026lt;iostream\u0026gt; using namespace std; struct stuff { unsigned int field1 : 30; unsigned int field2 : 4; unsigned int field3 : 3; }; int main(){ struct stuff s = {1,3,5}; cout \u0026lt;\u0026lt; s.field1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s.field2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s.field3 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; sizeof(3) \u0026lt;\u0026lt;endl; return 0; }  5. 位域的初始化  直接为结构体赋值：struct stuff s = {1,2,5}; 直接为位域成员赋值：s.field1 = 1;  6. 位域的重映射  例如下面的代码：  struct box { unsigned int ready : 2; unsigned int error : 2; unsigned int command : 4; unsigned int sector_no : 24; }b1;   利用重映射将位域归零  // 将“位域结构体的地址”映射到“整形（int *）的地址” int *p = (int *) \u0026amp;b1; // 清空，将各成员归零 *p = 0;   利用union将32bits位域重映射到unsigned int类型   union的性质：\n（1）一种特殊的类，也是一种构造类型的数据结构\n（2）一个 union 中可以定义多个不同类型的数据类型，在一个被声明为该 union 的变量中，可以装入 union 所定义的任何一种数据，它们共享同一段内存，节省空间\n（3）与 struct 的区别：struct 的总长度为各成员长度之和，union 的长度为成员中最长的长度\n  利用 union 将位域归零代码如下：  // 涉及到上面的代码 union uBox{ struct box stBox; unsigned int uiBox; }; union uBox u; u.uiBox = 0;  C实现C++面向对象特性 1. C++ 实现  多态：在C++中会维护一张虚函数表，其父类的指针或者引用可以指向子类对象； 若一个父类的指针或者引用调用父类的虚函数，则该父类的指针会在自己的虚函数表中查找自己的函数地址； 若一个父类的指针或者引用指向子类的对象，且该子类以近乎重写了父类的虚函数，则该指针会调用子类已经重写的虚函数； 代码如下：  #include \u0026lt;iostream\u0026gt; using namespace std; // class 默认访问修饰符和继承方式均为 private（私有） class A{ public : // 虚函数的实现 virtual void f(){ cout \u0026lt;\u0026lt; \u0026quot;父类 A：f()\u0026quot; \u0026lt;\u0026lt; endl; } }; class B : public A{ public : // 虚函数实现，子类中 virtual 关键字可以省略 virtual void f(){ cout \u0026lt;\u0026lt; \u0026quot;子类 B：f()\u0026quot; \u0026lt;\u0026lt; endl; } }; int main(){ A a; // 基类对象 B b; // 派生对象 A *pa = \u0026amp;a; // 父类的指针指向父类对象 pa -\u0026gt; f(); // 调用父类的函数 pa = \u0026amp;b; // 父类指针指向子类对象，多态实现 pa -\u0026gt; f(); // 调用派生类同名函数 return 0; }  2. C 实现  封装：由于 C 中没有 class，考虑使用 struct 来模拟，使用函数指针将属性与方法封装到结构体中； 继承：结构体嵌套 多态：由于 C 中结构体内部没有成员函数，考虑使用函数指针来模拟，但是父子各自的函数指针指向的不是类似C++中维护的虚函数表，而是一块物理内存，不宜模拟过多的函数； 模拟多态，必须要保持函数指针变量对齐，即内容上和变量对齐上完全一致，否则父类指针指向子类对象，会运行崩溃！ 代码如下：  // 注意这里使用的语言是 C #include \u0026lt;stdio.h\u0026gt; // 重定义一个函数指针类型 typedef void (*pf)(); // 父类 typedef struct _A{ pf _f; }A; // 子类 typedef struct _B{ // 在子类中定义一个基类的对象即可实现继承 A _b; }B; void funA(){ printf(\u0026quot;%s\\n\u0026quot; , \u0026quot;基类 A：fun()\u0026quot;); } void funB(){ printf(\u0026quot;%s\\n\u0026quot; , \u0026quot;子类 B：fun()\u0026quot;); } int main(){ A a; B b; // _f 是一个函数指针 a._f = funA; // 父类中的函数指针指向 funA 函数 b._b._f = funB; // 子类中的函数指针指向 funB 函数 A *pa = \u0026amp;a; // 父类的指针指向父类 pa -\u0026gt; _f(); // 调用父类函数 pa = (A *)\u0026amp;b; // 父类指针指向子类的对象，由于类型不匹配，需要进行强制转换 pa -\u0026gt; _f(); // 调用子类同名函数 return 0; }  const（常类型） 1. const作用  常类型的变量或对象的值是不能被更新的； 定义常量：const int a = 100; const 常量与 #define 宏定义常量的区别：  const 常量具有类型，编译器可以安全检查；#define 宏定义是字符串替换，不带类型，不利于安全检查； const 常量生效于编译的阶段，#define 宏定义处于预编译阶段；   const 定义的变量只有类型为整数或枚举，且以常量表达式初始化时才能作为常量表达式；其他情况只是一个 const 限定的变量，不要与常量混淆； 防止修改，起到保护作用，增强程序健壮性，如下面代码是错误的：  void f(const int i){ i++; // 错误！ }   节省空间，避免不必要的内存分配  const 定义常量从汇编的角度看，只是给出了对应的内存地址，而 #define 给出的是立即数； const 定义的常量在程序运行过程中只有一份拷贝，？？？    2. const 对象默认为文件局部变量  非 const 变量默认为extern，要使 const 变量能在其他文件中访问，必须在文件显式地指定它为 extern，且常量在定义时必须要初始化；  //extern_file1.cpp extern const int ext = 12; //extern_file2.cpp #include\u0026lt;iostream\u0026gt; extern const int ext; int main(){ std::cout \u0026lt;\u0026lt; ext \u0026lt;\u0026lt; std::endl; }  3. 指针与 const  指向  ","id":3,"section":"blog","summary":"纯虚函数与抽象类 1. 纯虚函数 没有函数体的虚函数； C++中的纯虚函数/抽象函数是没有实现的虚函数，只需要通过在声明中赋值0来实现纯虚函数。 // 抽象","tags":null,"title":"《C++那些事》阅读笔记：基础进阶","uri":"https://sleepshow.github.io/2022/05/cplusplusthings/","year":"2022"},{"content":"本文是通过观看尚硅谷的数据结构和算法视频总结的笔记，如有错误地方，欢迎指正。\n代码部分使用的语言是C++\n稀疏数组 1. 使用情况： 　当一个数组中的大部分元素为 0 或者同一值时，可采用稀疏数组进行压缩。\n2. 操作方法： 　（1）先记录数组中一共有多少行、多少列和多少个不同的值；\n（2）将不同值的元素的行数、列数和值用一个小数组记录；\n（3）小数组，即稀疏数组行数随原数组的值进行变化，列数共三列，分别表示行、列、对应的值；\n（4）如果原数组共有 n 个不同的值，则小数组的行数为 n+1，因为小数组的第一行存储总的行数、列数和不同值个数，第二行开始记录每个在原数组不同值对应的行和列；\n（5）将稀疏数组保存到磁盘中；\n3. 代码部分 　- 稀疏数组实现代码\n 栈（stack） 1.特点 　（1）先入后出的有序列表\n（2）栈底固定不变，栈顶随着数据输入输出而变化\n（3）入栈图\n- （4）出栈图\n- 2.使用场景 　（1）子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。\n（2）处理递归调用：除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。\n（3）表达式的转换\n（4）二叉树的遍历\n（5）图形的深度优先搜索法（dfs）\n3. 表达式 （1）前缀表达式（波兰表达式） 　- 特点：运算符均位于操作数之前。\n- 例如：- × + 3 4 5 6\n- 求值过程：从右向左扫描表达式，遇到数字，压入数字栈，遇到运算符，弹出栈顶两个数字进行运算，将结果压入数字栈；重复操作。\n（2）中缀表达式 　- 即常见的运算表达式\n- 例如：(3+4)×5-6\n（3）后缀表达式（逆波兰表达式） 　- 特点：运算符位于操作数之后\n- 例如：3 4 + 5 × 6 –    正常表达式 逆波兰表达式     a+b a b +   a+(b-c) a b c - +   a+(b-c)*d a b c – d * +    　- 求值过程：从左至右扫描表达式，遇到数字，压入数字栈，遇到运算符，弹出栈顶的两个数字，计算结果，并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果；\n- 【逆波兰计算器】中缀表达式转后缀表达式\n 队列（queue） 1. 特点 　（1）先入先出的有序列表\n（2）可以用数组或链表实现\n（3）队列的顶端、低端下标随着数据输入、输出而变化\n- 2. 模拟队列代码 　- 环形队列功能模拟代码\n 链表 1.特点 　（1）以节点的方式进行存储，属于链式存储\n（2）每个节点含有 data 域和 next 域，next 用于指向下一个节点\n2.单链表 　（1）带头节点链表示意图\n- （2）单链表代码\n- 【面试题】查找单链表中的倒数第k个结点\n- 【面试题】单链表的反转\n3.单向环形链表 　（1）约瑟夫环问题（Josephu）\n 问题描述：\n设编号为1，2，．．．n的n个人围坐一圈，约定编号为k（1\u0026lt;=k\u0026lt;=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。\n 　- - 约瑟夫环代码\n4.双向链表 　（1）不需要辅助节点就可以实现自我删除\n（2）用双向链表实现单向链表\n- 双向链表代码\n 递归 1.解决问题： 　（1）数学问题如：八皇后，汉诺塔，阶乘，迷宫，球和篮子等；\n（2）各种算法：快速排序，二分查找，分治算法等；\n（3）将用栈解决的问题变成用递归，使代码简洁。\n2.注意事项 　（1）每次执行一个方法时，就创建一个新的受保护的独立空间(栈空间)；\n（2）归必须向退出递归的条件逼近，否则就是无限递归；\n（3）当一个方法执行完毕，或者遇到return，就会返回，遵守：谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。\n3.走迷宫问题 　（1）示意图如下\n- （2）【递归】走迷宫，求最短路径\n4.八皇后问题 　（1）示意图如下\n- （2）【递归】八皇后问题（回溯算法）\n 排序算法 1.内部排序 　（1）特点：将需要处理的所有数据都加载到内部存储器中进行排序。\n（2）冒泡排序\n- 基本思想：对待排序序列从前向后，依次比较相邻元素的值，若发现不符合条件则交换，使值大/小的元素逐渐从前移向后部，就像水底下的气泡一样逐渐向上冒出。\n- 优化：在排序过程中设置一个标志flag，判断元素是否进行过交换，如果一趟比较下来没有进行过交换，就说明序列是有序的，减少时间。\n（3）选择排序\n- 基本思想：每次从未排序区间中选择出一个最小/大的数与未排序区间的第一个位置进行交换，重复上述过程。\n- （4）插入排序\n- 基本思想：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。\n- （5）希尔排序（插入改进版）\n- 基本思想：记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止；\n- - 【希尔排序】使用交换法\n- 【希尔排序】使用移动法\n（6）快速排序（冒泡改进版本）\n- 基本思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列；\n- - 【快速排序】代码部分\n（7）归并排序\n- 基本思想：采用分治策略\n- - 【归并排序】采用分治，代码实现\n（8）基数排序（桶排序扩展）\n- 基本思想：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。\n- 是稳定性排序，即不改变元素的相对位置，需要借助二维数组，属于空间换时间\n- - 【基数排序】代码实现\n2.外部排序 　使用情况：数据量过大，需要借助外部存储\n3.常用排序复杂度对比 　 查找算法 1.线性查找：逐一对比 2.二分查找：前提数组有序 3.插值查找 　（1）mid 是自适应的，即根据需要查找的值和左右边界而确定mid（公式）\n- - 【插值查找】代码实现\n（2）适应情况：数据量大，值分布均匀\n4.黄金分割法（斐波拉契查找法） 　（1）黄金分割值：0.618\n- （2）mid是位于黄金分割点附近，即 mid=low+F(k-1)-1\n 哈希表（散列） 1.特点 　通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数称为散列函数，存放记录的数组称为散列表。\n2.模拟哈希表代码 　- 哈希表代码实现\n 树 1.存储方式分析 　（1）数组存储\n- 优点：通过下标方式访问元素，速度快。\n- 缺点：如果要查找或插入具体某个值，(按一定顺序)会整体移动，效率较低。\n（2）链式存储\n- 优点：在一定程度上对数组存储方式有优化，比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好。\n- 缺点：在进行检索时，效率仍然较低，比如检索某个值，需要从头节点开始遍历。\n（3）树存储\n－ 优点：能提高数据存储，读取的效率，比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。\n2.二叉树 　（1）树示意图如下：\n- （2）二叉树：每个节点最多只能有两个节点；\n（3）满二叉树：二叉树的所有叶子节点都在最后一层，并且结点总数为 2^n -1（n为层数）；\n- （4）完全二叉树：二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续；\n- 3.二叉树的遍历 　（1）前序遍历：先输出父节点，再遍历左子树和右子树\n（2）中序遍历: 先遍历左子树，再输出父节点，再遍历右子树\n（3）后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点\n（4）二叉树遍历代码实现\n 图（graph） 1. 概念 　（1）由顶点（vertex）集合V、边（edge）集合E组成；\n（2）有向图：点到点之间是有方向的图；\n（3）无向图：点到点之间是没有方向的图；\n（4）带权图：图的边带有权/值的图；\n（5）环：图中含有一条从一个顶点到它自身的边；\n（6）圈：只在有向图中有意义，且路径长至少为1；\n（7）路径：一个顶点序列，路径的长是路径上的边数；\n（8）连通性：在一个无向图中从每一个顶点到每一个其他顶点都存在一条路径，称该无向图是连通的，有向图是强连通的；若一个有向图不是强连通的，但是其基础图（去掉方向的图）是连通的，称该有向图为弱连通的；\n（9）完全图：每对顶点间都存在着一条边的图；\n2. 表示方式 　（1） 二维数组 —— 邻接矩阵\n- 表示图形中顶点之间相邻关系的矩阵，对于每一条边，值为 1，否则为 0；\n- 邻接矩阵需要为每一个顶点分配 n 个边的空间，造成一定的空间损失，所以适用于稠密的图；\n（2）链表 —— 邻接表\n- 只存放存在的边，由数组+链表组成；\n- 如图，标号为 0 的结点的相关联结点为 1，2，3，4；\n- - 在实际应用中顶点是名字而不是数字，但是这些名字在编译时是未知的，因此需要提供从名字到数字的映射，可以适用散列表；\n- 在散列表中对每个顶点存储一个名字和一个范围在 1~|V| 的内部编号，编号在图被读入的时候指定；在每条边被输入时，通过查看其两个顶点是否在散列表中的方法，检查两个顶点是否都指定了一个数；\n- 如果在，使用这个内部编号，否则将下一个可用的编号分配给该顶点，并将顶点的名字和对应的编号插入散列表中。\n3. 深度优先搜索（dfs） 　（1）从初始访问结点出发，首先访问第一个邻接结点，然后以这个被访问的结点作为初始结点，访问其第一个邻接结点，重复操作；\n（2）访问策略：优先纵向挖掘深入，是一个递归过程；\n（3）搜索步骤（如下图）：\n- - 1 先访问初始结点，假设为 A，并且标记A为\u0026quot;已访问\u0026quot;；\n- 2 查找结点 A 的第一个邻接结点 B （指链表中存放的邻接结点）；\n- 3 若 B 存在，继续执行下一步；若 B 不存在，回到第一步，从 A 的下一个结点继续查找；\n- 4 若 B 未被访问，对 B 进行深度优先搜索（即将 B 作为初始结点，再次从第一步开始执行，这时候的初始结点为 B ）；\n4. 最短路径 —— 广度优先搜索（bfs） 　（1）按层搜索，需要使用队列保持访问过的结点顺序；\n（2）搜索步骤：\n- 1 访问初始结点 A，并且标记 A 为已经访问；\n- 2 结点 A 入队列；\n- 3 当队列非空时，继续执行，否则对 A 结点的搜索结束；\n- 4 出队列，得到队头结点 U；\n- 5 查找头结点 U 的第一个邻接结点 B；\n- 6 若 B 不存在，返回步骤 3；否则循环执行下面三个步骤；\n- 6.1 若结点 B 未被访问，则标记为已访问；\n- 6.2 结点 B 入队列；\n- 6.3 查找结点 U 的在邻接结点 B 之后的下一个邻接结点，转到步骤 6；\n（3）【bfs】相关题目代码\n5. 最短路径 —— Dijkstra 算法 　（1）按阶段进行，在每个阶段，Dijkstra 算法选择一个顶点 v，\n","id":4,"section":"blog","summary":"本文是通过观看尚硅谷的数据结构和算法视频总结的笔记，如有错误地方，欢迎指正。 代码部分使用的语言是C++ 稀疏数组 1. 使用情况： 当一个数组中的大部","tags":["数据结构和算法"],"title":"数据结构和算法笔记","uri":"https://sleepshow.github.io/2022/05/datastruct/","year":"2022"},{"content":"使用系统：windows10系统\n1.下载git  官网上有教程，跟着安装就行了。\n注意：一定要检查git是否在环境变量path中，如果不在就添加进去!\n2.下载hugo  1.选择一个存放地址，创建一个bin文件存放 hugo；\n2.创建一个site文件存放博客站点，将hugo.exe所在的文件地址添加到path环境用户变量中；\n3.检测是否安装成功：\n- 在命令提示符（建议以管理员身份运行）中，输入hugo help；\n- 出现信息，表示安装成功；\n3.创建本地网站  1.创建新站点\n- 在命令提示符内进入到 site 文件夹下(命令符：cd)；\n- 输入：hugo new site webname.com；\n- 最后会显示网站的本地访问地址；\n2.选择一个博客主题\n- 进入到 hugo官方网站，选择合适的主题；\n- 根据提示进行安装(使用git命令)\n- 打开git bash软件；\n- 进入到网站根目录下；\n- 根据主题描述输入安装命令；\n- 将下载主题文件夹下 exampleSite 中的config.yml的文件复制到网站根目录下（有时候后缀不一定是.yml）；\n3.创建博客文件\n- 在根目录下输入：hugo new posts/blog.md，会提示创建成功；\n- 可以用 markdown 或者 Visual Studio Code 软件编写内容；注意写的时候将draft变成false；\n- 然后进行预览，输入：hugo server -t 主题名 --buildDrafts；\n- 根据提示给的网站地址预览；\n- 这是实时刷新的，方便在写博客的时候随时查看效果；\n- 按ctrl+c结束；\n4.在github上创建仓库  1.2.- 填写的名字一定要与前面的名字一致，且是小写（图中是之前建过一次了）；\n3.5.将本地网站部署到 github 上  1.点击刚才建立的仓库；\n2.3.下图中 \u0026ndash;baseURL=\u0026quot;(地址)\u0026quot; \u0026ndash;theme=(主题名)；\n- 4.生成一个 public 文件；\n- 6.将 public 文件传到 github 仓库上，使别人能够远程进行访问  1.进入到 public 文件下；\n2.3.- 若出现异常，将长框里的命令复制输入，回车；\n- 再次输入：git add .；\n4.输入：git commit -m \u0026quot;(文字自定)\u0026quot;；\n- - 如出现框中的报错，输入框中的命令，\u0026quot; \u0026quot; 是你自己的信息，第一个是邮件名，第二个是下图文件名：\n- - 再次输入：git commit -m \u0026quot;(文字自定)\u0026quot;；\n5.出现下列信息表示成功\n- 7.进行关联  1.输入：git remote add origin 链接；\n2.这里的链接是：\n- - 注意大小写，不要忘记链接后面的 git ，如果输错了就删除远程git仓库；\n3.git remote rm origin（删除远程仓库），再进行关联；\n4.输入：git push -u origin master；\n- - 注意浏览器，它会弹出一个消息，点击绿色的选项进行即可；\n5.刷新git仓库，出现内容代表成功；\n- 8.查看是否可以远程访问，网站名就是仓库名；  1.如果出现404，进入仓库；\n-  - 2.如果上图框中是红色的叉：\n-  - - 点击红叉旁边的刷新按钮（图中是已经刷新过了的），等待；\n- 出现下列信息表示成功：\n-  以上是我创建博客的全过程，途中出现的异常是通过百度解决的，如有错误操作，欢迎指出。 ","id":5,"section":"blog","summary":"使用系统：windows10系统 1.下载git 官网上有教程，跟着安装就行了。 注意：一定要检查git是否在环境变量path中，如果不在就添加进","tags":["博客"],"title":"使用hugo在github上搭建博客","uri":"https://sleepshow.github.io/2022/05/createdhugo/","year":"2022"}],"tags":[{"title":"Sprague-Grundy","uri":"https://sleepshow.github.io/tags/sprague-grundy/"},{"title":"博客","uri":"https://sleepshow.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"title":"图形学","uri":"https://sleepshow.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"title":"数据结构和算法","uri":"https://sleepshow.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"title":"蓝图","uri":"https://sleepshow.github.io/tags/%E8%93%9D%E5%9B%BE/"}]}